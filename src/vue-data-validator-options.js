// Generated by CoffeeScript 1.11.1
(function() {
  var _, assignIfDifferently, empty, isArray, isBool, isNumber, isNumeric, isObject, isPromise, isString, isset;

  _ = require('./lodash.custom.js');

  isset = function(v) {
    return typeof v !== 'undefined';
  };

  isBool = function(v) {
    return Object.prototype.toString.call(v) === '[object Boolean]';
  };

  isString = function(v) {
    return Object.prototype.toString.call(v) === '[object String]';
  };

  isNumber = function(v) {
    return Object.prototype.toString.call(v) === '[object Number]';
  };

  isArray = function(v) {
    return Object.prototype.toString.call(v) === '[object Array]';
  };

  isObject = function(v) {
    return Object.prototype.toString.call(v) === '[object Object]';
  };

  isPromise = function(v) {
    return Object.prototype.toString.call(v) === '[object Promise]';
  };

  isNumeric = function(v) {
    var num;
    num = parseFloat(v);
    return !isNaN(num) && isNumber(num);
  };

  empty = function(v) {
    var i, k;
    if (!isset(v) || v === null) {
      return true;
    } else if (isset(v.length)) {
      return v.length === 0;
    } else if (isBool(v) || isNumber(v)) {
      return false;
    } else if (isNaN(v)) {
      return true;
    } else if (isObject(v)) {
      i = 0;
      for (k in v) {
        i++;
      }
      return i === 0;
    }
  };

  assignIfDifferently = function(obj, key, value) {
    if (obj[key] !== value) {
      return obj[key] = value;
    }
  };

  module.exports = {
    rules: {
      accepted: function(val) {
        return val === 'yes' || val === 'on' || val === true || val === 1 || val === '1';
      },
      alpha: function(val) {
        return /^[a-zA-Z]+$/.test(val);
      },
      alphaDash: function(val) {
        return /^[\w\-]+$/.test(val);
      },
      alphaNum: function(val) {
        return /^[\w]+$/.test(val);
      },
      array: function(val) {
        return isArray(val);
      },
      between: function(val, params) {
        return params[0] <= val && params[1] <= val;
      },
      boolean: function(val) {
        return [true, false, 1, 0, '1', '0'].includes(val);
      },
      confirmed: {
        handler: function(val, params, field, fields) {
          var relatedField;
          relatedField = fields[field.name + "Confirmation"];
          return val === relatedField.value;
        },
        sensitive: true
      },
      date: function(val) {
        return /^\d\d\d\d\-\d\d?\-\d\d? \d\d?:\d\d?:\d\d?$/.test(val);
      },
      different: {
        handler: function(val, params, field, fields) {
          var relatedField;
          relatedField = fields[params[0]];
          return val !== relatedField.value;
        },
        sensitive: true
      },
      email: function(val) {
        return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(val);
      },
      "in": function(val, params) {
        var list;
        list = isArray(params[0]) ? params[0] : params;
        return list.indexOf(val) > -1;
      },
      integer: function(val) {
        return /^\-?[1-9]\d*$/.test(val);
      },
      max: function(val, params) {
        return val <= params[0];
      },
      min: function(val, params) {
        return val >= params[0];
      },
      notIn: function(val, params) {
        var list;
        list = isArray(params[0]) ? params[0] : params;
        return list.indexOf(val) === -1;
      },
      numeric: function(val) {
        return isNumeric(val);
      },
      required: {
        handler: function(val, params, field) {
          assignIfDifferently(field, 'required', true);
          return !empty(val);
        },
        always: true
      },
      requiredWith: {
        handler: function(val, params, field, fields) {
          if (empty(fields[params[0]].value)) {
            assignIfDifferently(field, 'required', false);
            return true;
          } else {
            assignIfDifferently(field, 'required', true);
            return !empty(val);
          }
        },
        sensitive: true,
        always: true
      },
      same: {
        handler: function(val, params, field, fields) {
          var relatedField;
          relatedField = fields[params[0]];
          return val === relatedField.value;
        },
        sensitive: true
      },
      size: function(val, params) {
        return (val || '').toString().length === parseInt(params[0]);
      },
      string: function(val) {
        return isString(val);
      },
      length: function(val, params) {
        return (val || '').toString().length === parseInt(params[0]);
      },
      maxLength: function(val, params) {
        return (val || '').toString().length <= params[0];
      },
      minLength: function(val, params) {
        return (val || '').toString().length >= params[0];
      },
      lengthBetween: function(val, params) {
        var len;
        len = (val || '').toString().length;
        return (params[0] <= len && len <= params[1]);
      }
    },
    messages: {
      accepted: 'The :name must be accepted.',
      alpha: 'The :name may only contain letters.',
      alphaDash: 'The :name may only contain letters, numbers, and dashes.',
      alphaNum: 'The :name may only contain letters and numbers.',
      array: 'The :name must be an array.',
      between: 'The :name must be between :params[0] and :params[1].',
      boolean: 'The :name field must be true or false.',
      confirmed: 'The :name confirmation does not match.',
      date: 'The :name is not a valid date.',
      different: 'The :name and :params[0] must be different.',
      email: 'The :name must be a valid email address.',
      "in": 'The selected :name is invalid.',
      integer: 'The :name must be an integer.',
      max: 'The :name may not be greater than :params[0].',
      min: 'The :name must be at least :params[0].',
      notIn: 'The selected :name is invalid.',
      numeric: 'The :name must be a number.',
      required: 'The :name field is required.',
      requiredWith: 'The :name field is required when :params[0] is present.',
      same: 'The :name and :params[0] must match.',
      size: 'The :name must be :params[0] characters.',
      string: 'The :name must be a string.',
      length: 'The :name must be :params[0] characters.',
      maxLength: 'The :name may not be greater than :params[0] characters.',
      minLength: 'The :name must be at least :params[0] characters.',
      lengthBetween: 'The :name must be between :params[0] and :params[1] characters.'
    }
  };

}).call(this);
